# Copyright 2023 The triangulate Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This is executable pseudocode for an RL localiser."""

# Standard Imports
import argparse
import ast
import logging
import math
import os
import shutil
import subprocess
import tempfile

#  Third-party Imports
import numpy as np

# Local imports
# TODO(etbarr): deferred to speed proof of life

# Module setup

log = logging.getLogger(__name__)
rng = np.random.default_rng(seed=654)


# Utils

## AST utils


class LineVisitor(ast.NodeVisitor):
  """Visit intra-statement lines in a Python script.

  Attributes:
    insertion_points:
  """

  def __init__(self):
    self.insertion_points = []

  def visit(self, node):
    if isinstance(
        node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef, ast.Module)
    ):
      for i, child in enumerate(node.body):
        if isinstance(child, ast.Expr) and isinstance(
            child.value, ast.Constant
        ):
          continue  # Skip multiline string literals
        elif isinstance(child, (ast.Dict, ast.List)):
          continue  # Skip dictionary and list initializers
        elif hasattr(child, "lineno"):
          self.insertion_points.append((node, i))
    elif isinstance(node, ast.Expr) and isinstance(node.value, ast.Constant):
      return  # Skip multiline string literals
    self.generic_visit(node)


def get_insertion_points(tree: bytes) -> []:
  # Collect insertion points
  visitor = LineVisitor()
  visitor.visit(tree)
  insertion_points = visitor.insertion_points

  if not insertion_points:
    raise ValueError("No valid insertion points found.")

  return insertion_points


class IdentifierExtractor(ast.NodeVisitor):
  """This visitor extracts variables from an AST."""

  def __init__(self):
    self.identifiers = set()

  # This Google-violating function naming is required
  # to confirm with Python's builtin AST library's interface.
  def visit_Name(self, node):  # pylint: disable=invalid-name
    self.identifiers.add(node.id)

  def visit_Call(self, node):  # pylint: disable=invalid-name
    for arg in node.args:
      self.visit(arg)


def extract_identifiers(expr):
  """Parse a Python expression and extract its identifiers."""
  root = ast.parse(expr)
  visitor = IdentifierExtractor()
  visitor.visit(root)
  return visitor.identifiers


## End AST Utils


## Stats Utils


def sample_zipfian(
    num_samples: int, zipf_param: float = 1.5, support_size: int = 10
) -> np.ndarray:
  """Generate a sample set from a Zipfian distribution over an integer interval.

  Args:

  Args:

  Args:
      num_samples: The number of samples to return
      zipf_param: The powerlaw exponent
      support_size:  The size of the support, i.e. the width of the interval

  Returns:
      A sample set from a Zipfian
  """

  weights = 1.0 / np.power(np.arange(1, support_size + 1), zipf_param)
  weights /= np.sum(weights)

  return rng.choice(np.arange(1, support_size + 1), size=num_samples, p=weights)


def sample_wo_replacement_uniform(num_samples: int, support: []) -> np.ndarray:
  """Uniformly sample num_samples from [1, suppport].

  Args:
      num_samples: The number of samples to return
      support:  The upper bound of the sampled interval

  Returns:
      A sample set from the uniform over the support
  """
  if num_samples > len(support):
    raise ValueError(
        "When sampling with replacement, the number of samples cannot exceed"
        " the cardinality of the set."
    )
  return rng.choice(support, size=num_samples, replace=False)


## End Stats Utils

## File Utils


# TODO(etbarr):  Rewrite to use AST.
def write_lines_to_file(descriptor, lines_with_offsets):
  """Write lines to their paired offset in the given file descriptor.

  Args:
      descriptor:  File descriptor to which the to write the lines to their
        paired offsets
      lines_with_offsets:  A list of lines paired with a target offset
  """
  for offset, line in lines_with_offsets:
    descriptor.seek(offset)
    descriptor.write(line)


## End File utils

# Barebones RL


class State:
  """State generated by the environment and passed to the agent in RL loop.

  Attributes: codeview : [str] code lines in current agent window ise : str
  illegal state expression focal_expr : str current expression
      descriptor: file descriptor of program being debugged
      probes: [str x int] list of probes, which pair a query and an offset.
  """

  def set_ise(self, ise: str):
    try:
      compile(ise, "<string>", "eval")
    except SyntaxError as e:
      err_template = "Error: %s is an invalid Python expression."
      log.error(err_template, ise)
      # TODO(etbarr) add when Python 3.11 is available within Google
      # e.add_note(err_template % expr)
      raise e
    self.ise = ise

  def set_focal_expr(self, focal_expr: str):
    try:
      compile(focal_expr, "<string>", "eval")
    except SyntaxError as e:
      err_template = "Error: %s is an invalid Python expression."
      log.error(err_template, focal_expr)
      # TODO(etbarr) add when Python 3.11 is available within Google
      # e.add_note(err_template % expr)
      raise e
    self.focal_expr = focal_expr

  def __init__(self, descriptor, ise: str, focal_expr: str, probes=None):
    """State constructor."""
    self.codeview = descriptor.readlines()  # TODO(etbarr): catch exceptions?
    self.set_ise(ise)
    self.set_focal_expr(focal_expr)
    self.descriptor = descriptor
    if probes is None:
      self.probes = []
    else:
      self.probes = probes

  def get_illegal_state_expr_ids(self):
    """Return identifiers in the illegal state expression.

    Returns:
        Identifiers in the illegal state expression
    """
    return extract_identifiers(self.ise)

  def illegal_bindings(self):
    """Return f-string for reporting illegal bindings.

    Returns:
        Returns an f-string over the illegal bindings
    """
    idents = self.get_illegal_state_expr_ids()
    if not idents:
      return None
    ident = idents.pop()
    bindings = f"{ident} = " + "{" + f"{ident}" + "}"
    for ident in idents:
      bindings += f", {ident} = " + "{" + f"{ident}" + "}"
    return bindings

  def get_codeview(self):
    """Return codeview."""
    return self.codeview

  def to_string(self):
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    print(self.descriptor, self.codeview)
    # TODO(etbarr): implement.


class Agent:
  """Baseclass for a minimal RL agent.

  Attributes: total_reward : int the reward accumulator env : the agent's
  environment
  """

  def __init__(self, env, total_reward: int = 0):
    """Agent constructor.

    Args:
        env: handle to the environment.
        total_reward: accumulated reward

    Returns:
        An agent instance
    """
    self.env = env
    self.total_reward = total_reward

  def pick_action(self, state, reward: int) -> None:
    """Pick an action given the current state and reward.

    Args:
        state: Current state
        reward:  Reward for last action and current state

    Returns:
        None
    """
    print(
        f"abstract method, not sure it's needed; {state} {reward}",
        state,
        reward,
    )

  def add_probes(self, state: State, probes) -> None:
    """Add probes to the codeview of the state.

    Args:
        state: Current state
        probes:  list of probes, which pair queries and offsets

    Returns:
        None
    """
    for offset, query in probes:
      state.codeview.insert(offset, query)
    state.descriptor.seek(0)
    state.descriptor.writelines(state.codeview)

  def repr(self) -> str:
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    print(self.total_reward)


class Localiser(Agent):
  """Represent the localiser agent.

  Attributes: codeview : [str] code lines in current agent window ise : str
  illegal state expression focal_expression : str current expression
      descriptor: file descriptor to copy of program being debugged
      probes: [str x int] list of probes, which pair a query and an offset.

  Methods:
      generate_probes(self, state) -> []:
      pick_action(self, state : State, reward: int) -> None:
  """

  def _generate_probes_random(self, state):
    """Generate probes for the given state.

    Args:
      state: current state

    Returns:
      List of probes, which pair queries and offsets
    """

    state.descriptor.seek(0)
    insertion_points = get_insertion_points(ast.parse(state.descriptor.read()))
    samples = sample_zipfian(1, len(insertion_points))

    offsets = sample_wo_replacement_uniform(samples[0], insertion_points)[:, 1]
    offsets.sort()

    ise = (
        f"Illegal state predicate: {state.ise} = "
        + "{eval("
        + repr(state.ise) + ")}; "
    )
    isb = f"bindings: {state.illegal_bindings()}"
    query = 'f"' + ise + isb + '"'

    probes = []
    for offset in offsets:
      probes.append((offset, f"print({query})\n"))
    state.probes = probes

    return probes

  # TODO(etbarr): Build AST, reverse its edges and walk the tree from focal
  #       expression to control expressions and defs
  # Ignore aliases for now.
  def _generate_probes_baseline(self, state):
    """Use analysis techniques to generate probes for the given state.

    Args:
      state:

    Raises:
      NotImplementedError
    """
    raise NotImplementedError(f"Not implementated; {state}", state)

  # Answers two questions:  decides 1) where to query 2) what.
  # Returns list of probes
  def generate_probes(self, state) -> []:
    """Generate probes for the given state.

    To create each probe this, function must decide whether to query what.

    Args:
        state: current state

    Returns:
        Object contents serialised into a string.
    """
    return self._generate_probes_random(state)

  def pick_action(self, state, reward: int) -> None:
    """Pick action in state.

    Args:
        state: current state
        reward:  the reward for the previous state
    """
    # TODO(etbarr):  add action selection
    # pp.pprint(f"state.codeview = {state.codeview}, reward = {reward},
    #          self.total_reward = {self.total_reward}")
    self.add_probes(state, self.generate_probes(state))
    self.total_reward += reward
    self.env.live = False


class Environment:
  """Represent the RL environment.

  Attributes:
      buggy_program_name: str
      buggy_program_output: str
      instrumented_program_name: str
      steps: int
      max_burnin: int
      max_steps: int
      descriptor: typeof(file descriptor)
      state: State
  """

  def __init__(self, args):
    """Construct an environment instance.

    Although we instrument the buggy program with probes, these probes write
    their output to a new temporary file, leaving the buggy program's output
    unchanged.  Thus, if we do detect a change in that output, there is an
    error in the instrumentation.
    TODO(etbarr):  Add the argument, with a default, for the probe output
    file.

    Args:
        args:  command line arguments

    Returns:
        An environment instance
    """
    self.buggy_program_name = args.buggy_program_name
    self.buggy_program_output = set()
    self.descriptor = None
    self.steps = 0
    self.max_steps = args.max_steps
    if args.burnin != 0:
      self.max_burnin = math.ceil(args.burnin * self.max_steps)
    else:
      self.max_burnin = args.max_steps
    file_extension = os.path.splitext(self.buggy_program_name)[1]
    # TODO(etbarr) bl/284330538 fix extension kludge
    if file_extension != ".py":
      err_template = "Error: %s is not a Python script."
      log.error(err_template, self.buggy_program_name)
      raise ValueError(err_template, self.buggy_program_name)
    if not os.access(self.buggy_program_name, os.X_OK):
      err_template = "Error: %s is not executable."
      log.error(err_template, self.buggy_program_name)
      raise ValueError(err_template, self.buggy_program_name)
    collision_avoiding_prefix = "__"
    try:
      self.instrumented_program_name = os.path.join(
          tempfile.gettempdir(),
          collision_avoiding_prefix + self.buggy_program_name,
      )
      shutil.copyfile(self.buggy_program_name, self.instrumented_program_name)
    except IOError as e:
      raise IOError(
          "Unable to copy subject program to /tmp for instrumentation."
      ) from e
    try:
      self.descriptor = open(
          self.instrumented_program_name, "r+", encoding="utf-8"
      )
    except IOError as e:
      log.error("Error: Unable to open file '%s'.", self.buggy_program_name)
      raise e
    self.state = State(self.descriptor, args.illegal_state_expr, args.bug_trap)

    self.buggy_program_output.add(self.execute_subject())

  # TODO(etbarr) Gather and pass subject's parameters to it.
  def execute_subject(self) -> str:
    """Execute an instrumented version of the buggy program.

    Returns:
      Returns the subject's output, concatenating standard and error.

    Raises:
      CallProcessError if subprocess.run fails.
    """

    self.descriptor.seek(0)
    if self.descriptor.readline().strip().startswith("#!"):
      shebang = self.descriptor.readline().strip()[2:].strip()
    else:
      shebang = None

    if shebang:
      cmd = ["./" + self.instrumented_program_name]
    else:
      cmd = ["python3", self.instrumented_program_name]
    try:
      result = subprocess.run(
          cmd,
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE,
          text=True,
          check=True,
      )
      return result.stdout + result.stderr
    except subprocess.CalledProcessError as e:
      log.error("Error running instrumented program: %s", e.output)
      raise e
    except Exception as e:
      log.error("Error: %s", e)
      raise e

  def reward(self) -> int:
    """Return reward for current state.

    Returns:
        reward
    """
    # TODO(etbarr)
    return 1

  def terminate(self) -> bool:
    """Determine whether to terminate simulation.

    Returns:
        termination condition
    """

    if self.steps >= self.max_steps:
      return True
    return False

  def update(self, action) -> None:
    """Update simulation given the selected action.

    Args:
        action:  action selected by agent

    Raises:
    """
    match action:
      case "Placeholder":
        pass
      case _:
        pass
    self.steps += 1

    stdouterr = self.execute_subject()
    # Check that adding probes has not changed the buggy program's semantics
    # This check --- for whether we've seen the output during burnin ---
    # is an instance of the coupon collector's problem.
    if self.steps > self.max_burnin:
      error_message = (
          "Error: probe insertion or execution changed program semantics."
      )
      if stdouterr not in self.buggy_program_output:
        log.exception(error_message)
        raise AssertionError(error_message)

    self.buggy_program_output.add(stdouterr)
    # TODO(etbarr) Create and return a new state instance
    # Probe's write their output to a fresh file

  def to_string(self) -> str:
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    print("TODO")


def process_args():
  """Process command line arguments."""

  parser = argparse.ArgumentParser()

  parser.add_argument(
      "-p",
      "--buggy_program_name",
      required=True,
      help="the name of a buggy file",
  )
  parser.add_argument(
      "-b", "--bug", required=True, help="a bug-triggering input"
  )
  parser.add_argument(
      "-i",
      "--illegal_state_expr",
      required=True,
      help=(
          "A predicate defining illegal state; it is a fragment "
          "of the program's specification, which is almost never "
          "fully realised. Concretely, it will, for us, usually "
          "be the complement of an assertion."
      ),
  )
  parser.add_argument(
      "-t",
      "--bug_trap",
      required=True,
      help="program point at which the bug was observed",
  )

  parser.add_argument("-v", help="log level")
  # During burnin, the program stores outputs for later use to checking
  # whether injecting/executing probes has changed program semantics.
  help_message = (
      "Percentage of max_steps to use as burnin steps "
      "to tolerate nondeterministic buggy programs; "
      "zero (the default) disables burnin."
  )
  parser.add_argument(
      "-n", "--burnin", nargs="?", default=0, type=int, help=help_message
  )
  parser.add_argument(
      "-m",
      "--max_steps",
      nargs="?",
      default=10,
      type=int,
      help="maximum simulation steps",
  )
  parser.add_argument(
      "-o",
      "--probe_output_filename",
      nargs="?",
      const="__probeOutput.dmp",
      type=str,
      help="maximum simulation steps",
  )

  args = parser.parse_args()

  if not 0 <= args.burnin < 1:
    err_template = "Error: burnin period must fall into the interval [0,1)."
    log.error(err_template)
    raise ValueError(err_template)

  if args.__dict__.get("v", False):
    if 0 <= args.v < 6:
      logging.log_levels = [
          logging.NOTSET,
          logging.CRITICAL,
          logging.ERROR,
          logging.WARNING,
          logging.INFO,
          logging.DEBUG,
      ]
    logging.getLogger("localiser").setLevel(logging.log_levels[args.v])

  if not args.buggy_program_name:
    args.buggy_program_name = input(
        "Please enter the name of the buggy program: "
    )

  return args


def main():
  """Program entry point."""

  args = process_args()
  env = Environment(args)
  localiser = Localiser(env)

  while not env.terminate():
    env.update(
        localiser.pick_action(
            env.state, env.reward()
        )
    )

  try:
    os.remove(env.instrumented_program_name)
  except IOError as e:
    log.error(
        "Error: Unable to remove temp file '%s'.",
        env.instrumented_program_name,
    )
    raise e


if __name__ == "__main__":
  main()
