# Copyright 2023 The triangulate Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This is executable pseudocode for an RL localiser."""

# Standard Imports
import ast
import logging
import math
import os
import shutil
import subprocess
import tempfile

# Local imports
from triangulate import ast_utils
from triangulate import sampling_utils

# Module setup

log = logging.getLogger(__name__)

################################################################################
# Utils
################################################################################


# TODO(etbarr):  Rewrite to use AST.
def write_lines_to_file(descriptor, lines_with_offsets):
  """Write lines to their paired offset in the given file descriptor.

  Args:
      descriptor:  File descriptor to which the to write the lines to their
        paired offsets
      lines_with_offsets:  A list of lines paired with a target offset
  """
  for offset, line in lines_with_offsets:
    descriptor.seek(offset)
    descriptor.write(line)

################################################################################
# Barebones RL
################################################################################


class State:
  """State generated by the environment and passed to the agent in RL loop.

  Attributes: codeview : [str] code lines in current agent window ise : str
  illegal state expression focal_expr : str current expression
      descriptor: file descriptor of program being debugged
      probes: [str x int] list of probes, which pair a query and an offset.
  """

  def set_ise(self, ise: str):
    try:
      compile(ise, "<string>", "eval")
    except SyntaxError as e:
      err_template = "Error: %s is an invalid Python expression."
      log.error(err_template, ise)
      # TODO(etbarr) add when Python 3.11 is available within Google
      # e.add_note(err_template % expr)
      raise e
    self.ise = ise

  def set_focal_expr(self, focal_expr: str):
    try:
      compile(focal_expr, "<string>", "eval")
    except SyntaxError as e:
      err_template = "Error: %s is an invalid Python expression."
      log.error(err_template, focal_expr)
      # TODO(etbarr) add when Python 3.11 is available within Google
      # e.add_note(err_template % expr)
      raise e
    self.focal_expr = focal_expr

  def __init__(self, descriptor, ise: str, focal_expr: str, probes=None):
    """State constructor."""
    self.codeview = descriptor.readlines()  # TODO(etbarr): catch exceptions?
    self.set_ise(ise)
    self.set_focal_expr(focal_expr)
    self.descriptor = descriptor
    if probes is None:
      self.probes = []
    else:
      self.probes = probes

  def get_illegal_state_expr_ids(self):
    """Return identifiers in the illegal state expression.

    Returns:
        Identifiers in the illegal state expression
    """
    return ast_utils.extract_identifiers(self.ise)

  def illegal_bindings(self):
    """Return f-string for reporting illegal bindings.

    Returns:
        Returns an f-string over the illegal bindings
    """
    idents = self.get_illegal_state_expr_ids()
    if not idents:
      return None
    ident = idents.pop()
    bindings = f"{ident} = " + "{" + f"{ident}" + "}"
    for ident in idents:
      bindings += f", {ident} = " + "{" + f"{ident}" + "}"
    return bindings

  def get_codeview(self):
    """Return codeview."""
    return self.codeview

  def to_string(self):
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    print(self.descriptor, self.codeview)
    # TODO(etbarr): implement.


class Agent:
  """Baseclass for a minimal RL agent.

  Attributes: total_reward : int the reward accumulator env : the agent's
  environment
  """

  def __init__(self, env, total_reward: int = 0):
    """Agent constructor.

    Args:
        env: handle to the environment.
        total_reward: accumulated reward

    Returns:
        An agent instance
    """
    self.env = env
    self.total_reward = total_reward

  def pick_action(self, state, reward: int) -> None:
    """Pick an action given the current state and reward.

    Args:
        state: Current state
        reward:  Reward for last action and current state

    Returns:
        None
    """
    print(
        f"abstract method, not sure it's needed; {state} {reward}",
        state,
        reward,
    )

  def add_probes(self, state: State, probes) -> None:
    """Add probes to the codeview of the state.

    Args:
        state: Current state
        probes:  list of probes, which pair queries and offsets

    Returns:
        None
    """
    for offset, query in probes:
      state.codeview.insert(offset, query)
    state.descriptor.seek(0)
    state.descriptor.writelines(state.codeview)

  def repr(self) -> str:
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    return str(self.total_reward)


class Localiser(Agent):
  """Represent the localiser agent.

  Attributes: codeview : [str] code lines in current agent window ise : str
  illegal state expression focal_expression : str current expression
      descriptor: file descriptor to copy of program being debugged
      probes: [str x int] list of probes, which pair a query and an offset.

  Methods:
      generate_probes(self, state) -> []:
      pick_action(self, state : State, reward: int) -> None:
  """

  def _generate_probes_random(self, state):
    """Generate probes for the given state.

    Args:
      state: current state

    Returns:
      List of probes, which pair queries and offsets
    """

    state.descriptor.seek(0)
    tree = ast.parse(state.descriptor.read())
    insertion_points = ast_utils.get_insertion_points(tree)
    samples = sampling_utils.sample_zipfian(1, len(insertion_points))

    offsets = sampling_utils.sample_wo_replacement_uniform(
        samples[0], insertion_points
    )[:, 1]
    offsets.sort()

    ise = (
        f"Illegal state predicate: {state.ise} = "
        + "{eval("
        + repr(state.ise) + ")}; "
    )
    isb = f"bindings: {state.illegal_bindings()}"
    query = 'f"' + ise + isb + '"'

    probes = []
    for offset in offsets:
      probes.append((offset, f"print({query})\n"))
    state.probes = probes

    return probes

  # TODO(etbarr): Build AST, reverse its edges and walk the tree from focal
  #       expression to control expressions and defs
  # Ignore aliases for now.
  def _generate_probes_baseline(self, state):
    """Use analysis techniques to generate probes for the given state.

    Args:
      state:

    Raises:
      NotImplementedError
    """
    raise NotImplementedError(f"Not implementated; {state}", state)

  # Answers two questions:  decides 1) where to query 2) what.
  # Returns list of probes
  def generate_probes(self, state):
    """Generate probes for the given state.

    To create each probe this, function must decide whether to query what.

    Args:
        state: current state

    Returns:
        Object contents serialised into a string.
    """
    return self._generate_probes_random(state)

  def pick_action(self, state, reward: int) -> None:
    """Pick action in state.

    Args:
        state: current state
        reward:  the reward for the previous state
    """
    # TODO(etbarr):  add action selection
    # pp.pprint(f"state.codeview = {state.codeview}, reward = {reward},
    #          self.total_reward = {self.total_reward}")
    self.add_probes(state, self.generate_probes(state))
    self.total_reward += reward
    self.env.live = False


class Environment:
  """Represent the RL environment.

  Attributes:
      buggy_program_name: str
      buggy_program_output: str
      instrumented_program_name: str
      steps: int
      max_burnin: int
      max_steps: int
      descriptor: typeof(file descriptor)
      state: State
  """

  def __init__(self, args):
    """Construct an environment instance.

    Although we instrument the buggy program with probes, these probes write
    their output to a new temporary file, leaving the buggy program's output
    unchanged.  Thus, if we do detect a change in that output, there is an
    error in the instrumentation.
    TODO(etbarr):  Add the argument, with a default, for the probe output
    file.

    Args:
        args:  command line arguments

    Returns:
        An environment instance
    """
    self.buggy_program_name = args.buggy_program_name
    self.buggy_program_output = set()
    self.descriptor = None
    self.steps = 0
    self.max_steps = args.max_steps
    if args.burnin != 0:
      self.max_burnin = math.ceil(args.burnin * self.max_steps)
    else:
      self.max_burnin = args.max_steps
    file_extension = os.path.splitext(self.buggy_program_name)[1]
    # TODO(etbarr) bl/284330538 fix extension kludge
    if file_extension != ".py":
      err_template = "Error: %s is not a Python script."
      log.error(err_template, self.buggy_program_name)
      raise ValueError(err_template, self.buggy_program_name)
    if not os.access(self.buggy_program_name, os.X_OK):
      err_template = "Error: %s is not executable."
      log.error(err_template, self.buggy_program_name)
      raise ValueError(err_template, self.buggy_program_name)
    collision_avoiding_prefix = "__"
    try:
      self.instrumented_program_name = os.path.join(
          tempfile.gettempdir(),
          collision_avoiding_prefix + os.path.basename(self.buggy_program_name)
      )
      shutil.copyfile(self.buggy_program_name, self.instrumented_program_name)
    except IOError as e:
      raise IOError(
          "Unable to copy subject program to /tmp for instrumentation."
      ) from e
    try:
      self.descriptor = open(
          self.instrumented_program_name, "r+", encoding="utf-8"
      )
    except IOError as e:
      log.error("Error: Unable to open file '%s'.", self.buggy_program_name)
      raise e
    self.state = State(self.descriptor, args.illegal_state_expr, args.bug_trap)

    self.buggy_program_output.add(self.execute_subject())

  # TODO(etbarr) Gather and pass subject's parameters to it.
  def execute_subject(self) -> str:
    """Execute an instrumented version of the buggy program.

    Returns:
      Returns the subject's output, concatenating standard and error.

    Raises:
      CallProcessError if subprocess.run fails.
    """
    assert self.descriptor is not None
    self.descriptor.seek(0)
    if self.descriptor.readline().strip().startswith("#!"):
      shebang = self.descriptor.readline().strip()[2:].strip()
    else:
      shebang = None

    if shebang:
      cmd = ["./" + self.instrumented_program_name]
    else:
      cmd = ["python3", self.instrumented_program_name]
    try:
      result = subprocess.run(
          cmd,
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE,
          text=True,
          check=True,
      )
      return result.stdout + result.stderr
    except subprocess.CalledProcessError as e:
      log.error("Error running instrumented program: %s", e.output)
      raise e
    except Exception as e:
      log.error("Error: %s", e)
      raise e

  def reward(self) -> int:
    """Return reward for current state.

    Returns:
        reward
    """
    # TODO(etbarr)
    return 1

  def terminate(self) -> bool:
    """Determine whether to terminate simulation.

    Returns:
        termination condition
    """

    if self.steps >= self.max_steps:
      return True
    return False

  def update(self, action) -> None:
    """Update simulation given the selected action.

    Args:
        action:  action selected by agent

    Raises:
    """
    match action:
      case "Placeholder":
        pass
      case _:
        pass
    self.steps += 1

    stdouterr = self.execute_subject()
    # Check that adding probes has not changed the buggy program's semantics
    # This check --- for whether we've seen the output during burnin ---
    # is an instance of the coupon collector's problem.
    if self.steps > self.max_burnin:
      error_message = (
          "Error: probe insertion or execution changed program semantics."
      )
      if stdouterr not in self.buggy_program_output:
        log.exception(error_message)
        raise AssertionError(error_message)

    self.buggy_program_output.add(stdouterr)
    # TODO(etbarr) Create and return a new state instance
    # Probe's write their output to a fresh file

  def to_string(self) -> str:
    """Convert object into string representation.

    Returns:
        Object contents serialised into a string.
    """
    raise NotImplementedError()
